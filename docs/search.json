[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Neuroimage handling tutorial",
    "section": "",
    "text": "This is a brief preview of neuroimage I/O, manipulation, and analysis for R taught as a segment of the “Introduction to neuroimage analysis for biostatisticians” short course for the International Chinese Statistical Association 2024 conference."
  },
  {
    "objectID": "index.html#r-package-dependencies",
    "href": "index.html#r-package-dependencies",
    "title": "Neuroimage handling tutorial",
    "section": "2 R package dependencies",
    "text": "2 R package dependencies\nMost R neuroimaging packages are hosted on Neuroconductor We use the following packages (alphabetically listed):\n\npapayaWidget - embedded interactive visualization of Nifti images in html documents.\npbj - Parametric bootstrap joint inference for testing in neuroimaging data. Contains visualization functions for niftiImage objects.\nPCP - Preprocessed connectomes project package. Contains downloadABIDE function to get open-access imaging data from the Autism Brain Imaging Data Exchange.\nRNifti - Nifti Image I/O.\n\nThe following two code chunks install packages if needed and load all the packages required for the tutorial.\n\n# data frame of packages used in tutorial\npackages = data.frame(\n  packages = c('devtools', 'papayaWidget', 'PCP', 'RNifti', 'fslr', 'pbj'),\n  repos = c('cran', 'nc', 'statimagcoll/PCP', 'nc', 'nc', 'statimagcoll/pbj'))\ninds = which(!packages$packages %in% installed.packages()[,\"Package\"])\n\n\n# neuroconductor installer\nsource(\"https://neuroconductor.org/neurocLite.R\")\n\nfor(ind in inds){\n  repo = packages$repos[ind]\n  package=packages$packages[ind]\n  if(repo=='cran'){\n    install.packages(package)\n  } else if(repo=='nc'){\n    neuro_install(package)\n  } else {\n    devtools::install_github(repo)\n  }\n}\n\n\ndevtools::install_github('statimagcoll/PCP')\ninvisible(sapply(packages$packages, library, character.only=TRUE))"
  },
  {
    "objectID": "index.html#loading-and-visualizing-data-using-abide",
    "href": "index.html#loading-and-visualizing-data-using-abide",
    "title": "Neuroimage handling tutorial",
    "section": "3 Loading and visualizing data using ABIDE",
    "text": "3 Loading and visualizing data using ABIDE\nThe PCP::ABIDE function has many options to download preprocessed imaging data in the various modalities and formats discussed in this course. Here, we will download and visualize several types of data:\n\nCortical volumes from Freesurfer.\nNetwork connectivity data.\nfALFF voxel-level data in Nifti image format.\n\nFor visualizations, there are many quality checks we might make before analyzing the data.\n\n### DATA LOCATION ###\ndatadir = dirname(tempdir())\n\n# will be created by downloadABIDE\ntemplatefile = file.path(datadir, 'abide/neuroimaging/MNI152_T1_3mm.nii.gz')\n\n\n3.1 fALFF voxel-level data\n\nderivative='falff'\n\n#gcc -I\"/usr/share/R/include\" -DNDEBUG       -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-E8saoI/r-base-4.3.2=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2  -c pbj.c -o pbj.o\n\n# clang -arch arm64 -I\"/Library/Frameworks/R.framework/Resources/include\" -DNDEBUG   -I/opt/R/arm64/include    -fPIC  -falign-functions=64 -Wall -g -O2  -c pbj.c -o pbj.o\n\n# load in data and get directories\ndat = ABIDE(datadir, derivatives=derivative, force=FALSE)\n# downloads in parallel\n# dat = ABIDE(datadir, derivatives=derivative, force=TRUE, mc.cores=4)\nhead(dat$destfile_falff)\n\n[1] \"/media/disk2/tmp/neuroimaging/cpac/filt_global/falff/Caltech_0051456_falff.nii.gz\"\n[2] \"/media/disk2/tmp/neuroimaging/cpac/filt_global/falff/Caltech_0051457_falff.nii.gz\"\n[3] \"/media/disk2/tmp/neuroimaging/cpac/filt_global/falff/Caltech_0051458_falff.nii.gz\"\n[4] \"/media/disk2/tmp/neuroimaging/cpac/filt_global/falff/Caltech_0051459_falff.nii.gz\"\n[5] \"/media/disk2/tmp/neuroimaging/cpac/filt_global/falff/Caltech_0051460_falff.nii.gz\"\n[6] \"/media/disk2/tmp/neuroimaging/cpac/filt_global/falff/Caltech_0051461_falff.nii.gz\"\n\n\n\n\n3.2 Visual QC\nI’ve displayed the fALFF data for the first 30 subjects below so that we can visually evaluate the data quality. There are displayed as gray scale, with brighter colors indicating higher values.\n\nniftis = readNifti(dat$destfile_falff)\n\n# base R for visualization\npar(mfrow=c(2,5), mar=c(0,0,1.8,0)); \n# pbj:::image for pbj:::image.niftiImage\n# index - slice to visualize\n# lo - use \"layout\" to arrange images?\n# limits - bounds for coloring below lower limit is transparent, above is more yellow (or brightest color)\ninvisible(lapply(1:30, function(ind) {image(niftis[[ind]], BGimg=templatefile, index=45, lo=FALSE, limits=c(0), crop=FALSE); mtext(dat$sub_id[ind], outer=FALSE, fg='white')} ) )"
  },
  {
    "objectID": "index.html#preprocessing-and-image-manipulation",
    "href": "index.html#preprocessing-and-image-manipulation",
    "title": "Neuroimage handling tutorial",
    "section": "4 Preprocessing and image manipulation",
    "text": "4 Preprocessing and image manipulation\n\n4.1 fALFF mask creation\nThis excludes participants who have bad coverage. Given the visual quality check in the previous step, this will lean toward excluding subjects with bad image orientation. Ideally, it would be better just to visually check all subjects relative to the template image and exclude if they are not spatially registered accurately.\n\nimgs = simplify2array(readNifti(dat$destfile_falff) )\n# choose\n# number of people with zeros at that location\ninds=numeric()\nids = c()\nsubids = dat$sub_id\n# number of voxels with no zeros\nnnzero = 0\n# iteratively removes subjects who will increase the mask the largest\nwhile(nnzero<30000){\n  voxSums = rowSums(imgs==0, dims=3)\n  tab = as.data.frame(table(voxSums))\n  \n  nnzero=tab[1,2]\n  # number of unique voxels for each subject\n  uniquevox = apply(imgs, 4, function(img) sum(img==0 & voxSums==1) )\n  # number of subjects to remove based on those subjects decreasing the amount of unique zero voxels by 50%\n  inds = which.max(uniquevox)\n  cat('\\nIteration:\\nsubject removed: ', paste(subids[inds], collapse=', '), '\\nmask size is now ', nnzero+sum(uniquevox[inds]), '\\nNumber of voxels added:', sum(uniquevox[inds]) )\n  imgs = imgs[,,,-inds]\n  subids = subids[-inds]\n  nnzero=nnzero+sum(uniquevox[inds])\n}\n\n\nIteration:\nsubject removed:  51469 \nmask size is now  8606 \nNumber of voxels added: 5352\nIteration:\nsubject removed:  51478 \nmask size is now  22503 \nNumber of voxels added: 13897\nIteration:\nsubject removed:  50727 \nmask size is now  24579 \nNumber of voxels added: 2076\nIteration:\nsubject removed:  50209 \nmask size is now  26495 \nNumber of voxels added: 1916\nIteration:\nsubject removed:  50192 \nmask size is now  27386 \nNumber of voxels added: 891\nIteration:\nsubject removed:  50195 \nmask size is now  28363 \nNumber of voxels added: 977\nIteration:\nsubject removed:  50216 \nmask size is now  29109 \nNumber of voxels added: 746\nIteration:\nsubject removed:  51466 \nmask size is now  29692 \nNumber of voxels added: 583\nIteration:\nsubject removed:  51471 \nmask size is now  30272 \nNumber of voxels added: 580\n\n\n\n# subset the dataset to the participants we didn't exclude due to coverage\ndat = dat[ dat$sub_id %in% subids,]\n\n# now create the mask\n# load in the first image. We'll replace all values to make the mask\noverlap = mask = readNifti(dat$destfile_falff[1])\n# clear all values in the mask\nmask[,,] = 0\noverlap[,,] = 0\n# load in all the data again\nimgs = simplify2array(readNifti(dat$destfile_falff) )\n# mask is where every subject has coverage\nmask[,,] = apply(imgs>0, 1:3, all)\noverlap[,,] = apply(imgs>0, 1:3, sum)\n\nmaskfile = file.path(datadir, 'abide/neuroimaging/cpac/mask.nii.gz')\nwriteNifti(mask, maskfile)\nnvox = sum(mask)\n# get 90th quantile, which we can use for visualization\nulimit = quantile(apply(imgs, 4, function(x) x[mask!=0]), 0.9)\nrm(imgs)\nniftis = readNifti(dat$destfile_falff)\ntemplate = readNifti(templatefile)\n\nThis code renders the first 30 participants who passed our visual QA. We’ve now added the template head as the background image, so that we can see how well each participant fits the space of the template.\n\n# base R for visualization\npar(mfrow=c(2,5), mar=c(0,0,1.8,0))\n# pbj:::image for pbj:::image.niftiImage\n# index - slice to visualize\n# lo - use \"layout\" to arrange images?\n# limits - bounds for coloring below lower limit is transparent, above is more yellow (or brightest color)\ninvisible(lapply(1:30, function(ind) {image(niftis[[ind]], BGimg=templatefile, index=45, lo=FALSE, crop=FALSE, limits=c(0,ulimit)); mtext(dat$sub_id[ind], outer=FALSE)} ) )\n\n\n\n\n\n\n\n\n\n\nThe code below creates a visualization where each voxel value represents the number of people with data at that location. Often, analyses restrict to voxels where everyone has data i.e. where the voxel value is 1026\n\nimage(overlap, BGimg=template)\noverlapfile=file.path(dirname(maskfile), 'overlap.nii.gz')\nwriteNifti(overlap, file=overlapfile)\n# interactive visualization with template as background image\n# n = 1026, voxel value shows how many participants have data in that location.\npapaya(c(templatefile, overlapfile))\n\n\n\n\n\n\n\n\n\n\n4.2 PBJ Package below\nAll the code below is an example of working with the pbj R package that my group is developing. It’s an excerpt from the User’s Guide.\n\n\n4.3 Voxel-wise analysis with lmPBJ\nThe following code sets up variables we will use to analyze the data. We assume that the mean value of fALFF for people in the population is a linear function of sex, diagnostic group, site where the data were collected, and the motion covariates. We will compare this to a model that does not include diagnosis and another model that does not include age, so that we are testing for the effect of diagnosis and age separately at each location in the fALFF image. In addition, we will include weights for each participant that are proportional to the inverse of the the person’s mean frame displacement during the scan with the logic being that participants that move more will have noisier data [@vandekar_robust_2019]. These weights correspond to a working variance structure, i.e. they are an estimate of how we think the variance of the imaging data differs across study participants. If we use robust standard error estimates, then the weights do not have to be correctly specified as the inverse of the variance for each participant; more details are given below and in [PBJ analysis methods].\nThe mask file that was created above will be used to specify where in the image the analysis should be performed. The output file indicates where to save the output of pbjInference later in the analysis, and ncores controls how many cores will be used to perform the analysis. Finally, we include two example vectors of cluster forming thresholds that will be used for inference later.\n\n# need age_at_scan in both models for testing nonlinear functions\nform = paste0(\" ~ sex + age_at_scan + func_mean_fd + func_fber + func_outlier + dx_group + site_id\" )\nformred = paste0(\" ~ sex + age_at_scan + func_mean_fd + func_fber + func_outlier + site_id\")\nformredAge = paste0(\" ~ sex + dx_group + func_mean_fd + func_fber + func_outlier + site_id\")\n#  weights for each subject. Can be a character vector\nweights = \"func_mean_fd\"\nmask = maskfile\noutput = paste0(tempfile(), '.rdata')\nncores = 24\n\nThe following line fits the model and estimates the coefficient and test statistic for the diagnosis variable. By default, lmPBJ uses robust standard errors, which provide consistent standard error and RESI estimates, even if the weights, covariance structure, and mean model are not correctly specified. This means that the results are not sensitive to differences in variance structure related to diagnosis, motion, or site. This option can be changed by setting the robust argument to FALSE. The transform argument defaults to t; this means the test statistics are assumed to be approximately T-distributed at each voxel, and it converts to chi-squared statistics by converting them to \\(Z\\) statistics and squaring them. The template file is not required, but makes visualization easier down-the-road.\nWe can perform a similar analysis of age, using the same full model as input, but using the reduced formula with age removed.\n\n# remove one person missing mean displacement\ndat = dat[!is.na(dat$func_mean_fd),]\n# DX analysis\nabideDX = lmPBJ(dat$destfile_falff, form=form, formred=formred, mask=mask, data=dat, Winv=dat[,weights], template = templatefile)\nabideDX\n\nFull formula:   ~ sex + age_at_scan + func_mean_fd + func_fber + func_outlier + dx_group + site_id\nReduced formula:   ~ sex + age_at_scan + func_mean_fd + func_fber + func_outlier + site_id  \n30272  voxels in mask\nStatMap quantiles (0, 0.01, 0.05, 0.95, 0.99, 1):\n [ 0, 0, 0.01, 5.32, 9.18, 21.05 ]\nsqrtSigma: \n  [n =  1025 ; df =  1 ; rdf =  999 ]\nid variable is:\n NULL\nlmPBJ inference settings:\n  robust =  TRUE ; HC3 =  TRUE ; transform =  t\npbjInference not run yet.\n\n# Age analysis\nabideAge = lmPBJ(dat$destfile_falff, form=form, formred=formredAge, mask=mask, data=dat, Winv=dat[,weights], template = templatefile)\n\nPrinting the fitted statMap object at the terminal gives information about how the model was fit and the output values. We can visualize the results using a lightbox view with the image function, which calls the image.statMap method for objects of class statMap (Figure @ref(fig:abideDXlightbox)). The argument cft_p=0.05 indicates to show only regions with an uncorrected \\(p\\)-value less than \\(0.05\\).\n\nimage(abideDX, cft_p=0.05, crop=TRUE)\n\n\n\n\nDiagnostic differences in fALFF controlling for sex, age, motion, and site. Colors are signed -log10(p) values showing uncorrected \\(p \\le 0.05\\).\n\n\n\n\nIf the parameter tested is 1-dimensional (such as a T-test), the results are shown by default as signed \\(-log_{10}(p)\\). The results show clusters in posterior cingulate and parietal lobes that are positively associated with ASD diagnosis, as well as small clusters at the midline that are possibly due to motion artifact. The second call to image passes additional named arguments to the image.niftiImage function to more easily visualize the results (Figure @ref(fig:abideDXsag)).\n\nimage(abideDX, cft_p=0.05, plane='coronal',  index=seq(28, length.out=8), nrow=2, crop=FALSE)\n\n\n\n\nDiagnostic differences in fALFF controlling for sex, age, motion, and site. Colors are signed -log10(p) values showing uncorrected \\(p \\le 0.05\\). for slices z=28:36\n\n\n\n\nWe can also visualize the same result on the effect size scale using the same function with the cft_s=0.1 argument, which highlights regions where the effect size, \\(S\\), is larger than \\(0.1\\) (a small effect size; Figure @ref(fig:abideDXlightboxS); see Section REF).\n\nimage(abideDX, cft_s=0.1, plane='sagittal',  index=seq(28, length.out=8), nrow=2)\n\n\n\n\nDiagnostic differences in fALFF controlling for sex, age, motion, and site. Colors are signed RESI values showing uncorrected \\(S \\ge 0.1\\). for slices z=28:36.\n\n\n\n\nThe age analysis highlights regions of the brain in prefrontal cortex where there are differences associated with age, with estimated effect sizes larger than \\(S=0.1\\) and \\(S=0.15\\) (Figures @ref(fig:ABIDElmPBJage) and @ref(fig:ABIDElmPBJageSag)). Blue is negative and highlights regions where the reduction in fALFF has an effect size larger than \\(S=0.1\\).\n\n  image(abideAge, cft_s = 0.1, index=20:49)\n\n\n\n\nAge-related differences in fALFF controlling for sex, diagnosis, motion, and site. Colors are signed RESI values showing uncorrected \\(S\\ge 0.1\\). for slices z=20:49.\n\n\n\n\n\n  image(abideAge, cft_s = 0.15, index=14:49, plane='sagittal')\n\n\n\n\nAge-related differences in fALFF controlling for sex, diagnosis, motion, and site. Colors are signed RESI values showing uncorrected \\(S \\ge 0.1\\). for slices x=14:49.\n\n\n\n\n\n\n4.4 Topological inference (Maxima, CEI, CMI) and other stuff\nThe pbj User’s Guide has the full tutorial on completing a group-level analysis in R, including more interactive visualizations and plotting the results of particular regions of interest.\n\n\n4.5 Freesurfer cortical volumes\nThe cortical volumes estimated automatically by Freesurfer are available from the ABIDE package for download. Because they are regional estimates, they can be stored in a regular data frame object. The have not been QCed, so it’s up to the user to filter them. Freesurfer QC is typically a hands-on process, but there are some columns in the dataset\n\nderivative = 'freesurferstats'\nfsdat = ABIDE(datadir, derivatives=derivative, force=FALSE)\n\n# a little function to load in the region-wise data.\n# It needs to be parsed from text files\nreadStats = function(file){\n  out = readLines(file.path(file, 'lh.aparc.stats'))\n  hdr = rev(grep(\"^#\", out))[1]\n  nams = strsplit(out[hdr], split = ' ')[[1]][-c(1,2)]\n  values = apply(do.call(rbind, strsplit(gsub(' +', ' ', out[(hdr+1):length(out)]), split=' ')), 2, c, simplify = FALSE)\n  names(values) = nams\n  ldf = do.call(data.frame, values)\n  ldf[,'StructName'] = paste0('lh_', ldf[,'StructName'])\n  \n  out = readLines(file.path(file, 'rh.aparc.stats'))\n  hdr = rev(grep(\"^#\", out))[1]\n  nams = strsplit(out[hdr], split = ' ')[[1]][-c(1,2)]\n  values = apply(do.call(rbind, strsplit(gsub(' +', ' ', out[(hdr+1):length(out)]), split=' ')), 2, c, simplify = FALSE)\n  names(values) = nams\n  rdf = do.call(data.frame, values)\n  rdf[,'StructName'] = paste0('rh_', rdf[,'StructName'])\n  # return output\n  out = rbind(ldf, rdf)\n  out[,-1] = apply(out[,-1], 2, as.numeric)\n  out\n}\n\n# loads in all data from DK parcellation in long format\nallVols = do.call(rbind, mapply(function(filename, sub_id){\n  out = readStats(filename)\n  out$sub_id = sub_id\n  out\n}, filename=fsdat$`destdir_stats/lh.aparc.stats`, sub_id=fsdat$sub_id, SIMPLIFY=FALSE) )\n\n\nGM = allVols[ allVols$StructName=='rh_frontalpole', c('sub_id', 'GrayVol')]\nnames(GM)[2] = 'rh_frontalpole'\nfsdat = merge(fsdat, GM)\nplot(fsdat$age_at_scan, fsdat$rh_frontalpole)"
  }
]